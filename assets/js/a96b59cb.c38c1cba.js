"use strict";(globalThis.webpackChunkfrontend=globalThis.webpackChunkfrontend||[]).push([[7100],{650(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"ros2/index","title":"ROS 2 (Robot Operating System)","description":"Introduction to ROS 2","source":"@site/docs/ros2/index.md","sourceDirName":"ros2","slug":"/ros2/","permalink":"/docs/ros2/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ros2/index.md","tags":[],"version":"current","frontMatter":{"title":"ROS 2 (Robot Operating System)"}}');var o=i(4848),t=i(8453);const r={title:"ROS 2 (Robot Operating System)"},a="ROS 2 (Robot Operating System)",l={},c=[{value:"Introduction to ROS 2",id:"introduction-to-ros-2",level:2},{value:"Core Architecture",id:"core-architecture",level:2},{value:"DDS (Data Distribution Service)",id:"dds-data-distribution-service",level:3},{value:"Nodes",id:"nodes",level:3},{value:"The ROS Graph",id:"the-ros-graph",level:3},{value:"Communication Patterns",id:"communication-patterns",level:2},{value:"Topics",id:"topics",level:3},{value:"Services",id:"services",level:3},{value:"Actions",id:"actions",level:3},{value:"Python Integration (rclpy)",id:"python-integration-rclpy",level:2},{value:"URDF (Unified Robot Description Format)",id:"urdf-unified-robot-description-format",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"ros-2-robot-operating-system",children:"ROS 2 (Robot Operating System)"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-ros-2",children:"Introduction to ROS 2"}),"\n",(0,o.jsx)(n.p,{children:"The Robot Operating System (ROS) is a flexible framework for writing robot software. It is a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms."}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 is a complete redesign of the original ROS, built to address the needs of modern robotics applications, including multi-robot systems, real-time control, and commercial products. It is built on top of the Data Distribution Service (DDS) standard, which provides a robust and scalable communication layer."}),"\n",(0,o.jsx)(n.p,{children:"This chapter will provide a comprehensive overview of ROS 2, from its high-level architecture to its core communication patterns and development tools."}),"\n",(0,o.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,o.jsx)(n.p,{children:'At its heart, ROS 2 is a distributed system of processes (called "nodes") that communicate with each other to perform complex tasks.'}),"\n",(0,o.jsx)(n.h3,{id:"dds-data-distribution-service",children:"DDS (Data Distribution Service)"}),"\n",(0,o.jsx)(n.p,{children:"Unlike the original ROS, which used a custom communication protocol, ROS 2 is built on top of DDS. DDS is an industry-standard middleware for real-time and embedded systems. It provides a publish-subscribe communication model that is decentralized, scalable, and highly reliable."}),"\n",(0,o.jsx)(n.p,{children:"By using DDS, ROS 2 inherits many of its features, including:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Decentralized Discovery"}),": Nodes can automatically discover each other on the network without a central master."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Quality of Service (QoS)"}),": ROS 2 provides a rich set of QoS policies that allow developers to fine-tune the communication between nodes for different use cases (e.g., reliability, durability, latency)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Interoperability"}),": Different DDS implementations from different vendors can interoperate with each other. ROS 2 supports several DDS vendors, including eProsima Fast DDS (the default), RTI Connext, and Eclipse Cyclone DDS."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"nodes",children:"Nodes"}),"\n",(0,o.jsx)(n.p,{children:"A node is the fundamental building block of a ROS 2 system. It is a process that performs a specific task, such as:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Controlling a motor"}),"\n",(0,o.jsx)(n.li,{children:"Reading data from a sensor"}),"\n",(0,o.jsx)(n.li,{children:"Planning a path for the robot to follow"}),"\n",(0,o.jsx)(n.li,{children:"Visualizing data"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Nodes are typically written in C++ or Python using the ROS 2 client libraries (",(0,o.jsx)(n.code,{children:"rclcpp"})," and ",(0,o.jsx)(n.code,{children:"rclpy"}),"). They can be combined to create complex robot behaviors."]}),"\n",(0,o.jsx)(n.h3,{id:"the-ros-graph",children:"The ROS Graph"}),"\n",(0,o.jsxs)(n.p,{children:["The ROS Graph is the network of ROS 2 nodes and their connections. It is a conceptual representation of how the different parts of the system are communicating with each other. Tools like ",(0,o.jsx)(n.code,{children:"rqt_graph"})," can be used to visualize the ROS Graph and debug the communication between nodes."]}),"\n",(0,o.jsx)(n.h2,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 provides several communication patterns for nodes to exchange data."}),"\n",(0,o.jsx)(n.h3,{id:"topics",children:"Topics"}),"\n",(0,o.jsx)(n.p,{children:"Topics are the most common communication pattern in ROS 2. They provide an asynchronous, one-to-many communication channel based on the publish-subscribe model."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["A node can ",(0,o.jsx)(n.strong,{children:"publish"})," messages to a topic."]}),"\n",(0,o.jsxs)(n.li,{children:["Any number of other nodes can ",(0,o.jsx)(n.strong,{children:"subscribe"})," to that topic to receive the messages."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Topics are ideal for continuous data streams, such as sensor data (e.g., camera images, LiDAR scans) or robot state information (e.g., joint positions, odometry)."}),"\n",(0,o.jsxs)(n.p,{children:["Each topic has a specific ",(0,o.jsx)(n.strong,{children:"message type"}),", which defines the structure of the data being sent. ROS 2 provides a large set of standard message types, and developers can also create their own custom message types."]}),"\n",(0,o.jsx)(n.h3,{id:"services",children:"Services"}),"\n",(0,o.jsx)(n.p,{children:"Services provide a synchronous, one-to-one communication pattern based on the request-response model."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["A ",(0,o.jsx)(n.strong,{children:"client"})," node sends a request to a ",(0,o.jsx)(n.strong,{children:"server"})," node."]}),"\n",(0,o.jsx)(n.li,{children:"The server processes the request and sends back a response."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Services are used for short, transactional interactions, such as:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Querying the current state of a robot."}),"\n",(0,o.jsx)(n.li,{children:"Triggering a specific action (e.g., taking a picture)."}),"\n",(0,o.jsx)(n.li,{children:"Requesting a computation to be performed."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"actions",children:"Actions"}),"\n",(0,o.jsx)(n.p,{children:"Actions are used for long-running, asynchronous tasks that provide feedback during their execution."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["An ",(0,o.jsx)(n.strong,{children:"action client"})," sends a ",(0,o.jsx)(n.strong,{children:"goal"})," to an ",(0,o.jsx)(n.strong,{children:"action server"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:["The action server starts executing the goal and provides periodic ",(0,o.jsx)(n.strong,{children:"feedback"})," to the client."]}),"\n",(0,o.jsxs)(n.li,{children:["When the task is complete, the server sends a final ",(0,o.jsx)(n.strong,{children:"result"})," to the client."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Actions are ideal for tasks like:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Navigating to a specific location."}),"\n",(0,o.jsx)(n.li,{children:"Executing a complex manipulation task."}),"\n",(0,o.jsx)(n.li,{children:"Following a predefined trajectory."}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The action client can also cancel the goal at any time."}),"\n",(0,o.jsx)(n.h2,{id:"python-integration-rclpy",children:"Python Integration (rclpy)"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"rclpy"})," is the official Python client library for ROS 2. It provides a Pythonic interface to all the core ROS 2 concepts, allowing developers to write ROS 2 nodes, publishers, subscribers, services, and actions in Python."]}),"\n",(0,o.jsxs)(n.p,{children:['Here is a simple example of a "hello world" publisher in ',(0,o.jsx)(n.code,{children:"rclpy"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass HelloWorldPublisher(Node):\n\n    def __init__(self):\n        super().__init__('hello_world_publisher')\n        self.publisher_ = self.create_publisher(String, 'hello_world', 10)\n        timer_period = 0.5  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = 'Hello, ROS 2!'\n        self.publisher_.publish(msg)\n        self.get_logger().info('Publishing: \"%s\"' % msg.data)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    hello_world_publisher = HelloWorldPublisher()\n    rclpy.spin(hello_world_publisher)\n    hello_world_publisher.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"urdf-unified-robot-description-format",children:"URDF (Unified Robot Description Format)"}),"\n",(0,o.jsx)(n.p,{children:"The Unified Robot Description Format (URDF) is an XML format for describing the physical structure of a robot. It is a key component of the ROS ecosystem, used for modeling, simulation, and visualization."}),"\n",(0,o.jsx)(n.p,{children:"A URDF file defines:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Links"}),": The rigid parts of the robot."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Joints"}),": The connections between the links, which can be revolute (rotating), prismatic (sliding), or fixed."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Visual properties"}),": The shape and appearance of the links."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Collision properties"}),": The shape of the links used for collision detection."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Inertial properties"}),": The mass and inertia of the links."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"URDF files are used by tools like Gazebo for simulation and RViz for visualization. They are essential for any robotics application that requires a model of the robot's physical structure."}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"ROS 2 is a powerful and flexible framework for robotics development. Its modular architecture, robust communication patterns, and strong community support make it an ideal choice for a wide range of robotics applications, from simple hobbyist projects to complex industrial and commercial systems. This chapter has provided a solid foundation for understanding the core concepts of ROS 2. In the following chapters, we will dive deeper into each of these topics and learn how to use them to build our own robotic systems."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const o={},t=s.createContext(o);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);